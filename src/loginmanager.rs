// This code was autogenerated with dbus-codegen-rust, see https://github.com/diwic/dbus-rs

#![allow(dead_code)]
use dbus as dbus;
use dbus::arg;
use dbus::tree;

pub trait OrgFreedesktopDBusPeer {
    type Err;
    fn ping(&self) -> Result<(), Self::Err>;
    fn get_machine_id(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusPeer for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn ping(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Peer".into(), &"Ping".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_machine_id(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Peer".into(), &"GetMachineId".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let machine_uuid: String = i.read()?;
        Ok(machine_uuid)
    }
}

pub fn org_freedesktop_dbus_peer_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusPeer<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Peer", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.ping()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Ping", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let machine_uuid = d.get_machine_id()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(machine_uuid);
        Ok(vec!(rm))
    };
    let m = factory.method("GetMachineId", Default::default(), h);
    let m = m.out_arg(("machine_uuid", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusIntrospectable {
    type Err;
    fn introspect(&self) -> Result<String, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusIntrospectable for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn introspect(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Introspectable".into(), &"Introspect".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let data: String = i.read()?;
        Ok(data)
    }
}

pub fn org_freedesktop_dbus_introspectable_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    T: OrgFreedesktopDBusIntrospectable<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Introspectable", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let data = d.introspect()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(data);
        Ok(vec!(rm))
    };
    let m = factory.method("Introspect", Default::default(), h);
    let m = m.out_arg(("data", "s"));
    let i = i.add_m(m);
    i
}

pub trait OrgFreedesktopDBusProperties {
    type Err;
    fn get(&self, interface: &str, property: &str) -> Result<arg::Variant<Box<arg::RefArg + 'static>>, Self::Err>;
    fn get_all(&self, interface: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err>;
    fn set(&self, interface: &str, property: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopDBusProperties for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get(&self, interface: &str, property: &str) -> Result<arg::Variant<Box<arg::RefArg + 'static>>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Get".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface);
            i.append(property);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let value: arg::Variant<Box<arg::RefArg + 'static>> = i.read()?;
        Ok(value)
    }

    fn get_all(&self, interface: &str) -> Result<::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"GetAll".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>> = i.read()?;
        Ok(properties)
    }

    fn set(&self, interface: &str, property: &str, value: arg::Variant<Box<arg::RefArg>>) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.DBus.Properties".into(), &"Set".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(interface);
            i.append(property);
            i.append(value);
        })?;
        m.as_result()?;
        Ok(())
    }
}

pub fn org_freedesktop_dbus_properties_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Signal: Default,
    T: OrgFreedesktopDBusProperties<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.DBus.Properties", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let d = fclone(minfo);
        let value = d.get(interface, property)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(value);
        Ok(vec!(rm))
    };
    let m = factory.method("Get", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.out_arg(("value", "v"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let d = fclone(minfo);
        let properties = d.get_all(interface)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(properties);
        Ok(vec!(rm))
    };
    let m = factory.method("GetAll", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.out_arg(("properties", "a{sv}"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let interface: &str = i.read()?;
        let property: &str = i.read()?;
        let value: arg::Variant<Box<arg::RefArg>> = i.read()?;
        let d = fclone(minfo);
        d.set(interface, property, value)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Set", Default::default(), h);
    let m = m.in_arg(("interface", "s"));
    let m = m.in_arg(("property", "s"));
    let m = m.in_arg(("value", "v"));
    let i = i.add_m(m);
    let s = factory.signal("PropertiesChanged", Default::default());
    let s = s.arg(("interface", "s"));
    let s = s.arg(("changed_properties", "a{sv}"));
    let s = s.arg(("invalidated_properties", "as"));
    let i = i.add_s(s);
    i
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopDBusPropertiesPropertiesChanged {
    pub interface: String,
    pub changed_properties: ::std::collections::HashMap<String, arg::Variant<Box<arg::RefArg + 'static>>>,
    pub invalidated_properties: Vec<String>,
}

impl dbus::SignalArgs for OrgFreedesktopDBusPropertiesPropertiesChanged {
    const NAME: &'static str = "PropertiesChanged";
    const INTERFACE: &'static str = "org.freedesktop.DBus.Properties";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.interface, i);
        arg::RefArg::append(&self.changed_properties, i);
        arg::RefArg::append(&self.invalidated_properties, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.interface = i.read()?;
        self.changed_properties = i.read()?;
        self.invalidated_properties = i.read()?;
        Ok(())
    }
}

pub trait OrgFreedesktopLogin1Manager {
    type Err;
    fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err>;
    fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err>;
    fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, Self::Err>;
    fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, Self::Err>;
    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, Self::Err>;
    fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, Self::Err>;
    fn create_session(&self, arg0: u32, arg1: u32, arg2: &str, arg3: &str, arg4: &str, arg5: &str, arg6: &str, arg7: u32, arg8: &str, arg9: &str, arg10: bool, arg11: &str, arg12: &str, arg13: Vec<(&str, arg::Variant<Box<arg::RefArg>>)>) -> Result<(String, dbus::Path<'static>, String, dbus::OwnedFd, u32, String, u32, bool), Self::Err>;
    fn release_session(&self, arg0: &str) -> Result<(), Self::Err>;
    fn activate_session(&self, arg0: &str) -> Result<(), Self::Err>;
    fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), Self::Err>;
    fn lock_session(&self, arg0: &str) -> Result<(), Self::Err>;
    fn unlock_session(&self, arg0: &str) -> Result<(), Self::Err>;
    fn lock_sessions(&self) -> Result<(), Self::Err>;
    fn unlock_sessions(&self) -> Result<(), Self::Err>;
    fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), Self::Err>;
    fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), Self::Err>;
    fn terminate_session(&self, arg0: &str) -> Result<(), Self::Err>;
    fn terminate_user(&self, arg0: u32) -> Result<(), Self::Err>;
    fn terminate_seat(&self, arg0: &str) -> Result<(), Self::Err>;
    fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), Self::Err>;
    fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), Self::Err>;
    fn flush_devices(&self, arg0: bool) -> Result<(), Self::Err>;
    fn power_off(&self, arg0: bool) -> Result<(), Self::Err>;
    fn reboot(&self, arg0: bool) -> Result<(), Self::Err>;
    fn halt(&self, arg0: bool) -> Result<(), Self::Err>;
    fn suspend(&self, arg0: bool) -> Result<(), Self::Err>;
    fn hibernate(&self, arg0: bool) -> Result<(), Self::Err>;
    fn hybrid_sleep(&self, arg0: bool) -> Result<(), Self::Err>;
    fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), Self::Err>;
    fn can_power_off(&self) -> Result<String, Self::Err>;
    fn can_reboot(&self) -> Result<String, Self::Err>;
    fn can_halt(&self) -> Result<String, Self::Err>;
    fn can_suspend(&self) -> Result<String, Self::Err>;
    fn can_hibernate(&self) -> Result<String, Self::Err>;
    fn can_hybrid_sleep(&self) -> Result<String, Self::Err>;
    fn can_suspend_then_hibernate(&self) -> Result<String, Self::Err>;
    fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), Self::Err>;
    fn cancel_scheduled_shutdown(&self) -> Result<bool, Self::Err>;
    fn inhibit(&self, arg0: &str, arg1: &str, arg2: &str, arg3: &str) -> Result<dbus::OwnedFd, Self::Err>;
    fn can_reboot_to_firmware_setup(&self) -> Result<String, Self::Err>;
    fn set_reboot_to_firmware_setup(&self, arg0: bool) -> Result<(), Self::Err>;
    fn set_wall_message2(&self, arg0: &str, arg1: bool) -> Result<(), Self::Err>;
    fn get_enable_wall_messages(&self) -> Result<bool, Self::Err>;
    fn set_enable_wall_messages(&self, value: bool) -> Result<(), Self::Err>;
    fn get_wall_message(&self) -> Result<String, Self::Err>;
    fn set_wall_message(&self, value: String) -> Result<(), Self::Err>;
    fn get_nauto_vts(&self) -> Result<u32, Self::Err>;
    fn get_kill_only_users(&self) -> Result<Vec<String>, Self::Err>;
    fn get_kill_exclude_users(&self) -> Result<Vec<String>, Self::Err>;
    fn get_kill_user_processes(&self) -> Result<bool, Self::Err>;
    fn get_reboot_to_firmware_setup(&self) -> Result<bool, Self::Err>;
    fn get_idle_hint(&self) -> Result<bool, Self::Err>;
    fn get_idle_since_hint(&self) -> Result<u64, Self::Err>;
    fn get_idle_since_hint_monotonic(&self) -> Result<u64, Self::Err>;
    fn get_block_inhibited(&self) -> Result<String, Self::Err>;
    fn get_delay_inhibited(&self) -> Result<String, Self::Err>;
    fn get_inhibit_delay_max_usec(&self) -> Result<u64, Self::Err>;
    fn get_handle_power_key(&self) -> Result<String, Self::Err>;
    fn get_handle_suspend_key(&self) -> Result<String, Self::Err>;
    fn get_handle_hibernate_key(&self) -> Result<String, Self::Err>;
    fn get_handle_lid_switch(&self) -> Result<String, Self::Err>;
    fn get_handle_lid_switch_docked(&self) -> Result<String, Self::Err>;
    fn get_holdoff_timeout_usec(&self) -> Result<u64, Self::Err>;
    fn get_idle_action(&self) -> Result<String, Self::Err>;
    fn get_idle_action_usec(&self) -> Result<u64, Self::Err>;
    fn get_preparing_for_shutdown(&self) -> Result<bool, Self::Err>;
    fn get_preparing_for_sleep(&self) -> Result<bool, Self::Err>;
    fn get_scheduled_shutdown(&self) -> Result<(String, u64), Self::Err>;
    fn get_docked(&self) -> Result<bool, Self::Err>;
    fn get_remove_ipc(&self) -> Result<bool, Self::Err>;
    fn get_runtime_directory_size(&self) -> Result<u64, Self::Err>;
    fn get_inhibitors_max(&self) -> Result<u64, Self::Err>;
    fn get_ncurrent_inhibitors(&self) -> Result<u64, Self::Err>;
    fn get_sessions_max(&self) -> Result<u64, Self::Err>;
    fn get_ncurrent_sessions(&self) -> Result<u64, Self::Err>;
    fn get_user_tasks_max(&self) -> Result<u64, Self::Err>;
}

impl<'a, C: ::std::ops::Deref<Target=dbus::Connection>> OrgFreedesktopLogin1Manager for dbus::ConnPath<'a, C> {
    type Err = dbus::Error;

    fn get_session(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"GetSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_session_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"GetSessionByPID".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_user(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"GetUser".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_user_by_pid(&self, arg0: u32) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"GetUserByPID".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn get_seat(&self, arg0: &str) -> Result<dbus::Path<'static>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"GetSeat".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::Path<'static> = i.read()?;
        Ok(arg0)
    }

    fn list_sessions(&self) -> Result<Vec<(String, u32, String, String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ListSessions".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, u32, String, String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn list_users(&self) -> Result<Vec<(u32, String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ListUsers".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(u32, String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn list_seats(&self) -> Result<Vec<(String, dbus::Path<'static>)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ListSeats".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, dbus::Path<'static>)> = i.read()?;
        Ok(arg0)
    }

    fn list_inhibitors(&self) -> Result<Vec<(String, String, String, String, u32, u32)>, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ListInhibitors".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: Vec<(String, String, String, String, u32, u32)> = i.read()?;
        Ok(arg0)
    }

    fn create_session(&self, arg0: u32, arg1: u32, arg2: &str, arg3: &str, arg4: &str, arg5: &str, arg6: &str, arg7: u32, arg8: &str, arg9: &str, arg10: bool, arg11: &str, arg12: &str, arg13: Vec<(&str, arg::Variant<Box<arg::RefArg>>)>) -> Result<(String, dbus::Path<'static>, String, dbus::OwnedFd, u32, String, u32, bool), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CreateSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
            i.append(arg3);
            i.append(arg4);
            i.append(arg5);
            i.append(arg6);
            i.append(arg7);
            i.append(arg8);
            i.append(arg9);
            i.append(arg10);
            i.append(arg11);
            i.append(arg12);
            i.append(arg13);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        let arg1: dbus::Path<'static> = i.read()?;
        let arg2: String = i.read()?;
        let arg3: dbus::OwnedFd = i.read()?;
        let arg4: u32 = i.read()?;
        let arg5: String = i.read()?;
        let arg6: u32 = i.read()?;
        let arg7: bool = i.read()?;
        Ok((arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7))
    }

    fn release_session(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ReleaseSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn activate_session(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ActivateSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn activate_session_on_seat(&self, arg0: &str, arg1: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ActivateSessionOnSeat".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn lock_session(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"LockSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unlock_session(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"UnlockSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn lock_sessions(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"LockSessions".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn unlock_sessions(&self) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"UnlockSessions".into(), |_| {
        })?;
        m.as_result()?;
        Ok(())
    }

    fn kill_session(&self, arg0: &str, arg1: &str, arg2: i32) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"KillSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn kill_user(&self, arg0: u32, arg1: i32) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"KillUser".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn terminate_session(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"TerminateSession".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn terminate_user(&self, arg0: u32) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"TerminateUser".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn terminate_seat(&self, arg0: &str) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"TerminateSeat".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn set_user_linger(&self, arg0: u32, arg1: bool, arg2: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"SetUserLinger".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn attach_device(&self, arg0: &str, arg1: &str, arg2: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"AttachDevice".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn flush_devices(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"FlushDevices".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn power_off(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"PowerOff".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn reboot(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"Reboot".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn halt(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"Halt".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn suspend(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"Suspend".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn hibernate(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"Hibernate".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn hybrid_sleep(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"HybridSleep".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn suspend_then_hibernate(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"SuspendThenHibernate".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn can_power_off(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanPowerOff".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_reboot(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanReboot".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_halt(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanHalt".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_suspend(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanSuspend".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_hibernate(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanHibernate".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_hybrid_sleep(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanHybridSleep".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn can_suspend_then_hibernate(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanSuspendThenHibernate".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn schedule_shutdown(&self, arg0: &str, arg1: u64) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"ScheduleShutdown".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn cancel_scheduled_shutdown(&self) -> Result<bool, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CancelScheduledShutdown".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: bool = i.read()?;
        Ok(arg0)
    }

    fn inhibit(&self, arg0: &str, arg1: &str, arg2: &str, arg3: &str) -> Result<dbus::OwnedFd, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"Inhibit".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
            i.append(arg2);
            i.append(arg3);
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: dbus::OwnedFd = i.read()?;
        Ok(arg0)
    }

    fn can_reboot_to_firmware_setup(&self) -> Result<String, Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"CanRebootToFirmwareSetup".into(), |_| {
        })?;
        m.as_result()?;
        let mut i = m.iter_init();
        let arg0: String = i.read()?;
        Ok(arg0)
    }

    fn set_reboot_to_firmware_setup(&self, arg0: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"SetRebootToFirmwareSetup".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn set_wall_message2(&self, arg0: &str, arg1: bool) -> Result<(), Self::Err> {
        let mut m = self.method_call_with_args(&"org.freedesktop.login1.Manager".into(), &"SetWallMessage".into(), |msg| {
            let mut i = arg::IterAppend::new(msg);
            i.append(arg0);
            i.append(arg1);
        })?;
        m.as_result()?;
        Ok(())
    }

    fn get_enable_wall_messages(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "EnableWallMessages")
    }

    fn get_wall_message(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "WallMessage")
    }

    fn get_nauto_vts(&self) -> Result<u32, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NAutoVTs")
    }

    fn get_kill_only_users(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillOnlyUsers")
    }

    fn get_kill_exclude_users(&self) -> Result<Vec<String>, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillExcludeUsers")
    }

    fn get_kill_user_processes(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "KillUserProcesses")
    }

    fn get_reboot_to_firmware_setup(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RebootToFirmwareSetup")
    }

    fn get_idle_hint(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleHint")
    }

    fn get_idle_since_hint(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleSinceHint")
    }

    fn get_idle_since_hint_monotonic(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleSinceHintMonotonic")
    }

    fn get_block_inhibited(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "BlockInhibited")
    }

    fn get_delay_inhibited(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "DelayInhibited")
    }

    fn get_inhibit_delay_max_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "InhibitDelayMaxUSec")
    }

    fn get_handle_power_key(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandlePowerKey")
    }

    fn get_handle_suspend_key(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleSuspendKey")
    }

    fn get_handle_hibernate_key(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleHibernateKey")
    }

    fn get_handle_lid_switch(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitch")
    }

    fn get_handle_lid_switch_docked(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HandleLidSwitchDocked")
    }

    fn get_holdoff_timeout_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "HoldoffTimeoutUSec")
    }

    fn get_idle_action(&self) -> Result<String, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleAction")
    }

    fn get_idle_action_usec(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "IdleActionUSec")
    }

    fn get_preparing_for_shutdown(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "PreparingForShutdown")
    }

    fn get_preparing_for_sleep(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "PreparingForSleep")
    }

    fn get_scheduled_shutdown(&self) -> Result<(String, u64), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "ScheduledShutdown")
    }

    fn get_docked(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "Docked")
    }

    fn get_remove_ipc(&self) -> Result<bool, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RemoveIPC")
    }

    fn get_runtime_directory_size(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "RuntimeDirectorySize")
    }

    fn get_inhibitors_max(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "InhibitorsMax")
    }

    fn get_ncurrent_inhibitors(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NCurrentInhibitors")
    }

    fn get_sessions_max(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "SessionsMax")
    }

    fn get_ncurrent_sessions(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "NCurrentSessions")
    }

    fn get_user_tasks_max(&self) -> Result<u64, Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::get(&self, "org.freedesktop.login1.Manager", "UserTasksMax")
    }

    fn set_enable_wall_messages(&self, value: bool) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.login1.Manager", "EnableWallMessages", value)
    }

    fn set_wall_message(&self, value: String) -> Result<(), Self::Err> {
        <Self as dbus::stdintf::org_freedesktop_dbus::Properties>::set(&self, "org.freedesktop.login1.Manager", "WallMessage", value)
    }
}

pub fn org_freedesktop_login1_manager_server<F, T, D>(factory: &tree::Factory<tree::MTFn<D>, D>, data: D::Interface, f: F) -> tree::Interface<tree::MTFn<D>, D>
where
    D: tree::DataType,
    D::Method: Default,
    D::Property: Default,
    D::Signal: Default,
    T: OrgFreedesktopLogin1Manager<Err=tree::MethodErr>,
    F: 'static + for <'z> Fn(& 'z tree::MethodInfo<tree::MTFn<D>, D>) -> & 'z T,
{
    let i = factory.interface("org.freedesktop.login1.Manager", data);
    let f = ::std::sync::Arc::new(f);
    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_session(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSession", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_session_by_pid(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSessionByPID", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_user(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUser", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_user_by_pid(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetUserByPID", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.get_seat(arg0)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("GetSeat", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_sessions()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ListSessions", Default::default(), h);
    let m = m.out_arg(("", "a(susso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_users()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ListUsers", Default::default(), h);
    let m = m.out_arg(("", "a(uso)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_seats()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ListSeats", Default::default(), h);
    let m = m.out_arg(("", "a(so)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.list_inhibitors()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("ListInhibitors", Default::default(), h);
    let m = m.out_arg(("", "a(ssssuu)"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let arg1: u32 = i.read()?;
        let arg2: &str = i.read()?;
        let arg3: &str = i.read()?;
        let arg4: &str = i.read()?;
        let arg5: &str = i.read()?;
        let arg6: &str = i.read()?;
        let arg7: u32 = i.read()?;
        let arg8: &str = i.read()?;
        let arg9: &str = i.read()?;
        let arg10: bool = i.read()?;
        let arg11: &str = i.read()?;
        let arg12: &str = i.read()?;
        let arg13: Vec<(&str, arg::Variant<Box<arg::RefArg>>)> = i.read()?;
        let d = fclone(minfo);
        let (arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) = d.create_session(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8, arg9, arg10, arg11, arg12, arg13)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        let rm = rm.append1(arg1);
        let rm = rm.append1(arg2);
        let rm = rm.append1(arg3);
        let rm = rm.append1(arg4);
        let rm = rm.append1(arg5);
        let rm = rm.append1(arg6);
        let rm = rm.append1(arg7);
        Ok(vec!(rm))
    };
    let m = factory.method("CreateSession", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.in_arg(("", "u"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "u"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "a(sv)"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("", "o"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("", "h"));
    let m = m.out_arg(("", "u"));
    let m = m.out_arg(("", "s"));
    let m = m.out_arg(("", "u"));
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.release_session(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ReleaseSession", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.activate_session(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ActivateSession", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let d = fclone(minfo);
        d.activate_session_on_seat(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ActivateSessionOnSeat", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.lock_session(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("LockSession", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.unlock_session(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnlockSession", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.lock_sessions()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("LockSessions", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        d.unlock_sessions()?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("UnlockSessions", Default::default(), h);
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: i32 = i.read()?;
        let d = fclone(minfo);
        d.kill_session(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("KillSession", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let arg1: i32 = i.read()?;
        let d = fclone(minfo);
        d.kill_user(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("KillUser", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.in_arg(("", "i"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.terminate_session(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("TerminateSession", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let d = fclone(minfo);
        d.terminate_user(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("TerminateUser", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let d = fclone(minfo);
        d.terminate_seat(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("TerminateSeat", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: u32 = i.read()?;
        let arg1: bool = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        d.set_user_linger(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetUserLinger", Default::default(), h);
    let m = m.in_arg(("", "u"));
    let m = m.in_arg(("", "b"));
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: bool = i.read()?;
        let d = fclone(minfo);
        d.attach_device(arg0, arg1, arg2)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("AttachDevice", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.flush_devices(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("FlushDevices", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.power_off(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("PowerOff", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.reboot(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Reboot", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.halt(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Halt", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.suspend(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Suspend", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.hibernate(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("Hibernate", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.hybrid_sleep(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("HybridSleep", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.suspend_then_hibernate(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SuspendThenHibernate", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_power_off()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanPowerOff", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_reboot()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanReboot", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_halt()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanHalt", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_suspend()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanSuspend", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_hibernate()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanHibernate", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_hybrid_sleep()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanHybridSleep", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_suspend_then_hibernate()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanSuspendThenHibernate", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: u64 = i.read()?;
        let d = fclone(minfo);
        d.schedule_shutdown(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("ScheduleShutdown", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "t"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.cancel_scheduled_shutdown()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CancelScheduledShutdown", Default::default(), h);
    let m = m.out_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: &str = i.read()?;
        let arg2: &str = i.read()?;
        let arg3: &str = i.read()?;
        let d = fclone(minfo);
        let arg0 = d.inhibit(arg0, arg1, arg2, arg3)?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("Inhibit", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "s"));
    let m = m.out_arg(("", "h"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let d = fclone(minfo);
        let arg0 = d.can_reboot_to_firmware_setup()?;
        let rm = minfo.msg.method_return();
        let rm = rm.append1(arg0);
        Ok(vec!(rm))
    };
    let m = factory.method("CanRebootToFirmwareSetup", Default::default(), h);
    let m = m.out_arg(("", "s"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: bool = i.read()?;
        let d = fclone(minfo);
        d.set_reboot_to_firmware_setup(arg0)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetRebootToFirmwareSetup", Default::default(), h);
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let fclone = f.clone();
    let h = move |minfo: &tree::MethodInfo<tree::MTFn<D>, D>| {
        let mut i = minfo.msg.iter_init();
        let arg0: &str = i.read()?;
        let arg1: bool = i.read()?;
        let d = fclone(minfo);
        d.set_wall_message2(arg0, arg1)?;
        let rm = minfo.msg.method_return();
        Ok(vec!(rm))
    };
    let m = factory.method("SetWallMessage", Default::default(), h);
    let m = m.in_arg(("", "s"));
    let m = m.in_arg(("", "b"));
    let i = i.add_m(m);

    let p = factory.property::<bool, _>("EnableWallMessages", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_enable_wall_messages()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_enable_wall_messages(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("WallMessage", Default::default());
    let p = p.access(tree::Access::ReadWrite);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_wall_message()?);
        Ok(())
    });
    let fclone = f.clone();
    let p = p.on_set(move |iter, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        d.set_wall_message(iter.read()?)?;
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u32, _>("NAutoVTs", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_nauto_vts()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("KillOnlyUsers", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kill_only_users()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<Vec<&str>, _>("KillExcludeUsers", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kill_exclude_users()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("KillUserProcesses", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_kill_user_processes()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("RebootToFirmwareSetup", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_reboot_to_firmware_setup()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("IdleHint", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_idle_hint()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("IdleSinceHint", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_idle_since_hint()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("IdleSinceHintMonotonic", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_idle_since_hint_monotonic()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("BlockInhibited", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_block_inhibited()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("DelayInhibited", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_delay_inhibited()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InhibitDelayMaxUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_inhibit_delay_max_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("HandlePowerKey", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_handle_power_key()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("HandleSuspendKey", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_handle_suspend_key()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("HandleHibernateKey", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_handle_hibernate_key()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("HandleLidSwitch", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_handle_lid_switch()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("HandleLidSwitchDocked", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_handle_lid_switch_docked()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("HoldoffTimeoutUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_holdoff_timeout_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<&str, _>("IdleAction", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_idle_action()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("IdleActionUSec", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_idle_action_usec()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("PreparingForShutdown", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_preparing_for_shutdown()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("PreparingForSleep", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_preparing_for_sleep()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<(&str, u64), _>("ScheduledShutdown", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_scheduled_shutdown()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("Docked", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_docked()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<bool, _>("RemoveIPC", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_remove_ipc()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("RuntimeDirectorySize", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_runtime_directory_size()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("InhibitorsMax", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_inhibitors_max()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("NCurrentInhibitors", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_ncurrent_inhibitors()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("SessionsMax", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_sessions_max()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("NCurrentSessions", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_ncurrent_sessions()?);
        Ok(())
    });
    let i = i.add_p(p);

    let p = factory.property::<u64, _>("UserTasksMax", Default::default());
    let p = p.access(tree::Access::Read);
    let fclone = f.clone();
    let p = p.on_get(move |a, pinfo| {
        let minfo = pinfo.to_method_info();
        let d = fclone(&minfo);
        a.append(d.get_user_tasks_max()?);
        Ok(())
    });
    let i = i.add_p(p);
    let s = factory.signal("SessionNew", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("SessionRemoved", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("UserNew", Default::default());
    let s = s.arg(("", "u"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("UserRemoved", Default::default());
    let s = s.arg(("", "u"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("SeatNew", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("SeatRemoved", Default::default());
    let s = s.arg(("", "s"));
    let s = s.arg(("", "o"));
    let i = i.add_s(s);
    let s = factory.signal("PrepareForShutdown", Default::default());
    let s = s.arg(("", "b"));
    let i = i.add_s(s);
    let s = factory.signal("PrepareForSleep", Default::default());
    let s = s.arg(("", "b"));
    let i = i.add_s(s);
    i
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerSessionNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerSessionNew {
    const NAME: &'static str = "SessionNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerSessionRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerSessionRemoved {
    const NAME: &'static str = "SessionRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerUserNew {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerUserNew {
    const NAME: &'static str = "UserNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerUserRemoved {
    pub arg0: u32,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerUserRemoved {
    const NAME: &'static str = "UserRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerSeatNew {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerSeatNew {
    const NAME: &'static str = "SeatNew";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerSeatRemoved {
    pub arg0: String,
    pub arg1: dbus::Path<'static>,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerSeatRemoved {
    const NAME: &'static str = "SeatRemoved";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
        arg::RefArg::append(&self.arg1, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        self.arg1 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerPrepareForShutdown {
    pub arg0: bool,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForShutdown {
    const NAME: &'static str = "PrepareForShutdown";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}

#[derive(Debug, Default)]
pub struct OrgFreedesktopLogin1ManagerPrepareForSleep {
    pub arg0: bool,
}

impl dbus::SignalArgs for OrgFreedesktopLogin1ManagerPrepareForSleep {
    const NAME: &'static str = "PrepareForSleep";
    const INTERFACE: &'static str = "org.freedesktop.login1.Manager";
    fn append(&self, i: &mut arg::IterAppend) {
        arg::RefArg::append(&self.arg0, i);
    }
    fn get(&mut self, i: &mut arg::Iter) -> Result<(), arg::TypeMismatchError> {
        self.arg0 = i.read()?;
        Ok(())
    }
}
